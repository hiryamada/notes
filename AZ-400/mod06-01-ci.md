
## 継続的な統合の概要

- パイプラインを使用してプロジェクトの作業を自動化することができる
- Azure Pipelineを使用してパイプラインを構築することができる
- Azure Reposなどからのソースコードの取得、ビルド、デプロイなどのタスクを実行できる

このモジュールでは一歩踏み込んで、CI（継続的インテグレーション）の詳細と、Azure Pipelinesでの実装について学ぶ。

### 継続的な統合の概要

継続的インテグレーションとは。

[継続的インテグレーション(CI)](https://docs.microsoft.com/ja-jp/devops/develop/what-is-continuous-integration) とは、チーム メンバーがバージョン管理 に変更をコミットするたび、コードのビルドとテストを自動的に行うプロセス。

- コードをコミットする
- 自動化されたビルド システムが起動
- 共有リポジトリから最新のコードを取得
- ビルド、テスト、および検証

### 継続的インテグレーションの 4 つの柱

継続的インテグレーションの4つの構成要素とは。

- バージョン管理システム
  - Git など
- パッケージ管理システム
  - NuGet、NPM など
- 継続的インテグレーションシステム
  - Azure DevOps（Azure Pipelines）、Jenkins、TeamCity、Circle CIなど。
- 自動ビルド プロセス
  - Ant、Gradleなど

どのプラットフォームとツールを使用するかは、プロジェクトチームで選択する。

[Azure Pipelinesと連携して使えるかどうかを確認](https://docs.microsoft.com/ja-jp/azure/devops/pipelines/ecosystems/ecosystems?view=azure-devops)するとよい。

### 継続的インテグレーションの利点

継続的インテグレーションのメリットとは。

- 迅速なフィードバックに基づいてコード品質を向上させる
  - フィードバック: ビルドやテストが失敗する場合、そのことをすばやく発見できる
- あらゆるコード変更の自動テストをトリガーする
  - パイプラインの中で自動テストを実行できる。
- 迅速なフィードバックと問題の早期発見 (リスク低減) のためにビルド時間を短縮する
  - ビルドが人手ではなく、自動で実行される。
- 技術的負債の管理とコード分析の実施を改善する
  - [モジュール3](mod03.md)で学習済み。
- 長く、難しく、バグを誘発するマージを減らす
  - かつて、CIを使わないマージには人手と時間が必要だった。
  - マージを専門に行う[「マージ担当者」や「マージ部署」があった](https://www.ishikihikui-kei.com/entry/version-manage)。
  - [マージ（Wikipedia）](https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8_(%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0))
  - マージ職人、ビルド職人、リリース職人などの「職人」に頼るしかなかった
- 運用環境のデプロイのかなり前から、コードベースの健全性に対する信頼を高める


### ディスカッション - CI 実装の課題

講師（山田）は昔、開発案件で、[Jenkins](https://cloudbees.techmatrix.jp/jenkins/), [AWS CodePipeline](https://aws.amazon.com/jp/codepipeline/) などを使用したことがあります。課題としては、昔はJenkinsのサーバー自体をセットアップするのが大変だったという記憶があります（その点、AWS CodePipelineはすぐに使えて便利でした）。かなり昔の開発現場では、CIという仕組みを使っておらず、プログラマがそれぞれ自分の端末で開発したコードをSubversionにコミットし、その後共用のビルド&テストのサーバーでそれぞれ勝手にビルドして動作確認する、といったことをしていました（そのサーバーは1台しかないので順番待ちになりがちでした）。みなさんはいかがですか？

なにか思い出や教訓などがございましたら、ぜひチャットに書き込んでください。

### ビルドの番号の書式とステータス

ビルド番号とは。

パイプラインの実行(run)には、「ビルド番号」が付与される。

簡単に言えば、ビルドのたびに番号が付与され、その番号は1ずつ増やされる。

[参考1](https://www.atmarkit.co.jp/icd/root/69/65528369.html)

> プログラムの開発工程において、コンパイルやアセンブル、リンクなどの作業を経て最終的な実行プログラムを生成することをビルドするというが、ビルドされた実行プログラムを識別するために付けられたユニークな番号のことをビルド番号という。通常は、1回ビルドするたびにビルド番号を1つずつ増加させ、どのビルド（によって生成されたプログラム）であるかを識別するために使われる。
> 
> ビルド番号はバージョン番号と似ているが、その意味は異なっている。バージョン番号は、プログラムの機能や開発時期、リンクするライブラリ・モジュールのバージョンの違いなどに応じて異なる番号が与えられるが、ビルド番号は単にビルドした回数を反映した、最終生成物の識別用の番号に過ぎない。
> 
> ...
> 
> ビルドをテストしたり、ユーザーに配布したりするためには、バージョン番号ではなく、どのビルドであるかを簡単に特定できることが望ましい。このために利用されるのがビルド番号である。例えばテストの結果、以前のビルド100にあった不具合が本日のビルド101では修正されている、というふうに利用できる。
> 
> ビルド番号は、基本的には開発者が使う内部的な識別番号であるが、場合によっては積極的に公開している場合もある。例えばマイクロソフト社が開発しているWindows XP ProfessionalというOSには「Microsoft Windows XP [Version 5.1.2600]」という番号が付いている。「5.1」はOSのメジャーとマイナー・バージョン番号であり、「2600」はビルド番号2600を表している。これは、最初のWindows NTから数えて、2600回目のビルドであるということを表している。

[参考2](https://e-words.jp/w/%E3%83%93%E3%83%AB%E3%83%89%E7%95%AA%E5%8F%B7.html)

> オペレーティングシステム（OS）のような大規模なソフトウェアでは、あるバージョンの開発を始めてから発売までに数千回のビルドとテストを繰り返す場合もある。発売・公開後もビルドの更新が継続されることも多く、自動アップデートなどを通して利用者に新しいビルドが送り届けられる。


ビルド「番号」とはいっても数値とは限らず、プロジェクト名、ブランチ名、日付、時刻などを組合わせることができる。

ビルド番号により、各ビルド（パイプラインの実行による成果物）に、チームにとって意味のある、より便利な名前（情報）を付け加えることができる。たとえば「ビルド 2935」よりも「ビルド Fabrikam_CIBuild_master_20190505.2」のほうが情報量が多いため、ある特定のビルドをより的確に表すことができる。

ビルド番号はカスタマイズすることができる。[実行番号またはビルド番号を構成する](https://docs.microsoft.com/ja-jp/azure/devops/pipelines/process/run-number?view=azure-devops&tabs=yaml)

YAMLファイル内にて以下のようにして`name`で定義し、`$(Build.BuildNumber)`で参照する。

```
name: $(TeamProject)_$(Build.DefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

steps:
  - script: echo '$(Build.BuildNumber)' # ビルド番号を参照（出力）
```

`name:` の右側の`$(Rev:.r)` のような部分をトークンと呼ぶ。トークンは実行時に日付、時刻、プロジェクト名、リビジョン（ビルドの回数をカウントする整数）などに置換される。

最大文字数は255文字。

指定しない場合、一意の整数が指定される。


■バージョン番号との違いは？

バージョン番号は、ビルド番号とは違い、開発者が割り当てる。最近は「セマンティックバージョニング」に従ってバージョン番号を付与する場合が多い。

バージョン番号は、[Gitのタグで記録する](https://www.google.com/search?q=%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0+git+tag)。

成果物をパッケージとしてリリースする際は、ビルド番号ではなく、[Gitタグに基づくバージョン番号を付与する](https://docs.github.com/ja/github/administering-a-repository/releasing-projects-on-github/about-releases)。

各バージョンで何が変更されたのかという情報については、モジュール4で解説した「変更ログ」（Changelog）に記載される。

バージョン番号は、基本的には開発者が手動で番号を割り当てていく（上げていく）ものなので、[間違いがあったり、具体的にどの部分が変更されたのかがバージョン番号からはわからないといった問題がある](https://sdl.ist.osaka-u.ac.jp/pman/pman3.cgi?DOWNLOAD=412)。

■セマンティックバージョニングとは？

参考: [セマンティックバージョニング](https://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0)


> セマンティック・バージョニング（英語：Semantic Versioning）とは、ソフトウェアのバージョニング方法の一つ。
> 「1.23.45」といったように"."で区切った3つの数字で表される。
> 
> 前から順にメジャーバージョン、マイナーバージョン、パッチバージョンと呼ぶ。
> 
> APIの変更に互換性のない場合はメジャーバージョンを、後方互換性があり機能性を追加した場合はマイナーバージョンを、後方互換性を伴うバグ修正をした場合はパッチバージョンを上げる。


[.NET Coreのバージョン番号規則もセマンティックバージョニングに従っている](https://docs.microsoft.com/ja-jp/dotnet/core/versions/)。

[semantic-release](https://github.com/semantic-release/semantic-release)というパッケージを使うことで、コミットのメッセージに従って、適切なセマンティックバージョニングを行うことができる（コミットメッセージを正しく書いていることが前提）。

### ビルド承認のタイムアウトとバッジ

- ジョブアクセストークンとは？
- タイムアウトとは？
- バッジとは？

#### ビルドジョブの承認スコープ (Build job authorization scope)

ドキュメント: [参照先の Azure DevOps リポジトリにジョブ承認スコープを制限する](https://docs.microsoft.com/ja-jp/azure/devops/pipelines/process/access-tokens)

■「ジョブアクセストークン」とは？

実行時に、パイプライン内の各ジョブが Azure DevOps 内の他のリソースにアクセスすることがあります。

Azure Pipelines は、「ジョブアクセストークン」を使用してこれらのタスクを実行します。 「ジョブアクセストークン」 は、実行時に各ジョブの Azure Pipelines によって動的に生成されるセキュリティトークンです。

ジョブが実行されているエージェントは、Azure DevOps 内のこれらのリソースにアクセスするために、「ジョブアクセストークン」を使用します。

■「ジョブアクセストークン」の「スコープ」（承認スコープ）とは？

「ジョブアクセストークン」のスコープは「コレクション」または「プロジェクト」に設定できます。

スコープが組織レベルまたはプロジェクトレベルで制限されていない場合、YAML パイプライン内のすべてのジョブは、「コレクションスコープ」の「ジョブアクセストークン」を取得します。 言い換えると、**パイプラインは組織の任意のプロジェクト内の任意のリポジトリにアクセスできます**。

パイプラインが パブリックプロジェクト 内にある場合、どの設定で構成したかに関係なく、ジョブの承認スコープは自動的に プロジェクト に制限されます。 パブリックプロジェクト内のジョブは、プロジェクト内でのみビルド成果物やテスト結果などのリソースにアクセスでき、組織の他のプロジェクトからはアクセスできません。

■デフォルトの設定は？

新しい組織とプロジェクトが2020年5月以降に作成された場合、既定では、参照先の Azure DevOps リポジトリに対するジョブ承認スコープ が有効になります。

■「スコープ」を設定できる場所は？

「組織」または「プロジェクト」レベルで設定できる。

- Azure DevOps 組織で設定
- 特定のプロジェクトで設定

#### ビルドジョブのタイムアウト (Build job timeout in minutes)

[タイムアウト](https://docs.microsoft.com/ja-jp/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml#timeouts): ジョブが応答していない場合や待機時間が長すぎる場合にリソースが使用されないようにするには、ジョブの実行を許可する期間の制限を設定することをお勧めします。 Job timeout 設定を使用して、ジョブを実行するための制限を分単位で指定します。 値を 0 に設定すると、ジョブを時間制限なく実行できることを意味します。

#### バッジ

ビルドの状態を「バッジ」（ステータスバッジ）として、GitHubのトップページ（README）に表示することができる。[ドキュメント](https://docs.microsoft.com/ja-jp/azure/devops/pipelines/create-first-pipeline?view=azure-devops&tabs=java%2Ctfs-2018-2%2Cbrowser#add-a-status-badge-to-your-repository)

参考:
- https://maku.blog/p/teq2cmv/
- https://tech-blog.cloud-config.jp/2020-12-21-status-badge-of-azure-devops/
